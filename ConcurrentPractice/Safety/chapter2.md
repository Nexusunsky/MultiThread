##线程安全性

    1，定义：
        线程安全的核心概念就是正确性：某个类的行为与其规范是否一致；
        在多线程调用环境中，主调代码中不需要额外的线程安全的(同步，协同)处理，这个类都能变现出正确的行为，我们就称这个类是线程安全的；
    
    2，无状态的对象是线程安全的；
    
###一，原子性    
   
    1，竞态条件：并发编程中，由于不恰当的执行时序而出现不正确的结果的情况；
    常见场景：先检查后执行； 
    本质：基于某种可能已经失效的观察结果来最初判断或者执行某个判断
   
    2，复合操作；
    避免竞态条件问题就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成前或之后读取和
    修改状态，而不是在修改状态的过程中。
    
    假定有两个操作A，B。如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不不执行B，那么A和B对彼此来说是原子的。
    原子操作是指：对于访问同一个状态的所有操作（包括该操作本身），这个操作是一个以原子方式执行的操作。
    
    实际情况中，应尽可能使用现有的线程安全对象来管理类的状态，与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况
    要更为容易，从而也更容易维护和验证线程安全性。         
    
###二，加锁机制
    
    1，线程安全性要求：多个线程之间的操作无论是采用何种执行时序或交替方式，都要保证不变性条件不被破坏。

####要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量
    
    2，内置锁
     Java提供一种内置的锁机制来支持原子性：synchronized block   
     同步代码块包括两部分：一，作为锁的对象引用监视器  二，作为由这个锁所保护的代码块   
            
    3，重入
      某个线程请求一个由其他线程持有的锁时，发出请求饿的线程就会阻塞。
      内置锁是可重入的，因此某个线程试图获取一个已经由它自己持有的锁时，那么这个请求就会成功。
      
###三，用锁来保护状态
    
    1，通过锁来构造一些协议，实现对共享状态的独占访问，只要遵循这些协议，就能确保状态的一致性；
    2，同步协调对某个变量的访问，那么在访问这个变量的所有位置上都需同步；
    3，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁；
    4，加锁约定：将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问；
    5，类的不变性条件涉及多个状态变量时，那么这每一个相关的变量都必须由同一个锁来保护；      
    
    
###四，生存性和性能
    
    1，通过对象内置锁来保护每一个状态，通过设置方法级别的粗力度的锁来实现同步的性能开销很大；
    2，通过缩小同步代码块的作用范围来平衡线程的安全性和性能，划分时不要将本应该是原子的操作拆分到多个同步代码块中，尽量将不影响共享状态
    并且执行事件过长的操作从同步代码块中移除，确保每个同步代码块中的代码路径都足够短；
    3，使用两种不同的同步机制不仅会带来混乱，也不会在性能上带来任何好处；
    4，获取锁和释放锁都是需要很大的性能开销；
    5，在简答性和性能之间存在着相互制约因素，当实现某个同步策略时，一定不要盲目为了性能二牺牲简单性；
    6，当执行时间较长的计算或是可能无法快速完成的操作（网络I/O，控制台I/O）时，一定不要持有锁；
    
###1，线程安全的核心在于对队形状态访问操作进行管理。

###2，对象状态的安全性需要采用不同机制来协同对对象可变状态的访问。    

###3，并发编程时，首先使代码正确执行，然后再提高代码速度。

###4，设计线程安全的类时，良好的面向对象，不可修改性，以及明晰的不变性规范都能起到一定的帮助作用。    