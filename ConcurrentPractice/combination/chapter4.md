##对象的组合
    
    已知线程安全合同的一些基础知识，将现有的线程安全组件组合为更大规模的组件或程序；
    
###一，设计线程安全的类
    
    1，通过封装技术，可以对整个系统分析判断一个类是否是线程安全的：
    设计线程安全类的过程中，三要素：
        1，找出构成对象状态的所有变量
        2，找出约束状态变量的不变性条件
        3，建立对象状态的并发访问管理策略
        
    2，同步策略：
        定义了如何在不违背对象不变性条件或后验条件下的情况下对其状态的访问操作进行协同。
        规定了如何将不可变性，线程封闭与加锁机制等结合起来以维护线程的安全性。
    
    3，确保线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏；
    
    4，对象和变量都有一个状态空间，即所有可能的取值，状态空间越小，就越容易判断线程的状态。
    
    5，如果类的不变性条件中包含了多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。    

####如果不了解对象的不变性条件和后验条件，那么就不能保证线程安全性
####要满足在状态变量或状态转换上的各种约束条件，就需要借助于原子性和封装性。    

    6，依赖状态的操作
       类的不变性条件与后验条件约束了在对象上与哪些状态和转换是有效的。
       某些对象的方法还包括一些基于状态的先验条件，这些就是依赖状态的操作。
       
    7，状态的所有权
        所有权与封装总是相互关联的：对象封装它拥有的状态，同时对象对它封装的状态拥有所有权。
        如果对象发布了某个可变对象的引用，那么就不再拥有独占所有权，最多是共享控制权。
        
###二，对象封闭

    1，封装简化了线程安全类的实现过程，它提供了一种对象封闭机制（Instance Confinement）。
    
    2，当一个对象封装到另一个对象中时，能够访问被封装对象的所有路径都是已知的，
    那么通过封闭机制与合适的加锁策略结合起来，可以确保以非线程安全的方式来使用线程安全的对象。

####将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁

    3，Java类库中提供了包装器工厂方法，使得这些非线程安全的类可以在对线程环境中安全使用。
    这些工厂方法通过装饰器模式将容器封装在一个同步的包装器对象上，而包装器能将接口中的每个方法都实现为同步方法，
    并将调用请求转发到底层的容器对象上。
    
    4，将一个本该封闭的对象发布出去，就会破坏封闭性。
    
####封闭机制更容易构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。

    5，Java监视器模式
        遵循Java监视器模式的对象会把对象的所有状态都封装起来，并由对象的内置锁来保护。
        对于任何一种锁对象，只要自始自终都是用该对象锁，都可以用来保护对象的状态。        
    
###三，线程安全性的委托
    
    1，独立的状态变量
        当类的不变性条件不依赖与组合而成的类的多个变量，那么这些变量就是彼此对立的。
            
    2，当委托失效时
        大多数组合对象都不会只是包含独立的状态变量，在它们的状态变量之间存在某些不变性条件。
        
        如果某个类含有复合操作，那么仅靠委托并不足以实现线程安全性。
        那么这个类必须提供自己的加锁机制以保证这些复合操作时原子性的，除非整个复合操作都可以委托给状态变量。

####如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。     

    3，发布底层的状态变量
####如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个对象。        

###四，在现有的线程安全类中添加功能
    
    1，添加一个性的原子操作，最安全的方法是修改原始类。
    
    2，然后可以扩展这个类，假定这个类设计时考虑了扩展性。
        但是这种方式比直接修改源码要脆弱，因为现在的同步策略实现被分布到多个单独维护的代码中，
        如果底层类改变了同步策略，并选择不同的锁来保护它的状态变量，那么无法使用正确的锁来实现对基类状态的并发访问。
    
    3，客户端加锁
        通过添加一个原子操作扩展类是脆弱的，因为将类的锁代码分布到多个类中，
        然而客户端加锁更加脆弱，因为它将类C的加锁代码放到与C完全无关的其他类中。
        当在那些并不遵循加锁策略的类上使用客户端加锁是，特别小心。
        
        
    4，组合
        为现有类添加原子操作是，一种更好的方式：组合
                       